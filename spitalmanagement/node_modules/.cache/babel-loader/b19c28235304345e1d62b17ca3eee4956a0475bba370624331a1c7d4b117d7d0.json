{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateSections = exports.removeLocalizedDigits = exports.parseSelectedSections = exports.mergeDateIntoReferenceDate = exports.isStringNumber = exports.isAndroid = exports.getSectionsBoundaries = exports.getSectionVisibleValue = exports.getSectionValueText = exports.getSectionValueNow = exports.getSectionOrder = exports.getLocalizedDigits = exports.getLetterEditingOptions = exports.getDaysInWeekStr = exports.getDateSectionConfigFromFormatToken = exports.getDateFromDateSections = exports.doesSectionFormatHaveLeadingZeros = exports.createDateStrForV7HiddenInputFromSections = exports.createDateStrForV6InputFromSections = exports.cleanLeadingZeros = exports.cleanDigitSectionValue = exports.changeSectionValueFormat = exports.applyLocalizedDigits = exports.adjustSectionValue = exports.FORMAT_SECONDS_NO_LEADING_ZEROS = void 0;\nvar _dateUtils = require(\"../../utils/date-utils\");\nconst getDateSectionConfigFromFormatToken = (utils, formatToken) => {\n  const config = utils.formatTokenMap[formatToken];\n  if (config == null) {\n    throw new Error([`MUI X: The token \"${formatToken}\" is not supported by the Date and Time Pickers.`, 'Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported.'].join('\\n'));\n  }\n  if (typeof config === 'string') {\n    return {\n      type: config,\n      contentType: config === 'meridiem' ? 'letter' : 'digit',\n      maxLength: undefined\n    };\n  }\n  return {\n    type: config.sectionType,\n    contentType: config.contentType,\n    maxLength: config.maxLength\n  };\n};\nexports.getDateSectionConfigFromFormatToken = getDateSectionConfigFromFormatToken;\nconst getDeltaFromKeyCode = keyCode => {\n  switch (keyCode) {\n    case 'ArrowUp':\n      return 1;\n    case 'ArrowDown':\n      return -1;\n    case 'PageUp':\n      return 5;\n    case 'PageDown':\n      return -5;\n    default:\n      return 0;\n  }\n};\nconst getDaysInWeekStr = (utils, format) => {\n  const elements = [];\n  const now = utils.date(undefined, 'default');\n  const startDate = utils.startOfWeek(now);\n  const endDate = utils.endOfWeek(now);\n  let current = startDate;\n  while (utils.isBefore(current, endDate)) {\n    elements.push(current);\n    current = utils.addDays(current, 1);\n  }\n  return elements.map(weekDay => utils.formatByString(weekDay, format));\n};\nexports.getDaysInWeekStr = getDaysInWeekStr;\nconst getLetterEditingOptions = (utils, timezone, sectionType, format) => {\n  switch (sectionType) {\n    case 'month':\n      {\n        return (0, _dateUtils.getMonthsInYear)(utils, utils.date(undefined, timezone)).map(month => utils.formatByString(month, format));\n      }\n    case 'weekDay':\n      {\n        return getDaysInWeekStr(utils, format);\n      }\n    case 'meridiem':\n      {\n        const now = utils.date(undefined, timezone);\n        return [utils.startOfDay(now), utils.endOfDay(now)].map(date => utils.formatByString(date, format));\n      }\n    default:\n      {\n        return [];\n      }\n  }\n};\n\n// This format should be the same on all the adapters\n// If some adapter does not respect this convention, then we will need to hardcode the format on each adapter.\nexports.getLetterEditingOptions = getLetterEditingOptions;\nconst FORMAT_SECONDS_NO_LEADING_ZEROS = exports.FORMAT_SECONDS_NO_LEADING_ZEROS = 's';\nconst NON_LOCALIZED_DIGITS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\nconst getLocalizedDigits = utils => {\n  const today = utils.date(undefined);\n  const formattedZero = utils.formatByString(utils.setSeconds(today, 0), FORMAT_SECONDS_NO_LEADING_ZEROS);\n  if (formattedZero === '0') {\n    return NON_LOCALIZED_DIGITS;\n  }\n  return Array.from({\n    length: 10\n  }).map((_, index) => utils.formatByString(utils.setSeconds(today, index), FORMAT_SECONDS_NO_LEADING_ZEROS));\n};\nexports.getLocalizedDigits = getLocalizedDigits;\nconst removeLocalizedDigits = (valueStr, localizedDigits) => {\n  if (localizedDigits[0] === '0') {\n    return valueStr;\n  }\n  const digits = [];\n  let currentFormattedDigit = '';\n  for (let i = 0; i < valueStr.length; i += 1) {\n    currentFormattedDigit += valueStr[i];\n    const matchingDigitIndex = localizedDigits.indexOf(currentFormattedDigit);\n    if (matchingDigitIndex > -1) {\n      digits.push(matchingDigitIndex.toString());\n      currentFormattedDigit = '';\n    }\n  }\n  return digits.join('');\n};\nexports.removeLocalizedDigits = removeLocalizedDigits;\nconst applyLocalizedDigits = (valueStr, localizedDigits) => {\n  if (localizedDigits[0] === '0') {\n    return valueStr;\n  }\n  return valueStr.split('').map(char => localizedDigits[Number(char)]).join('');\n};\nexports.applyLocalizedDigits = applyLocalizedDigits;\nconst isStringNumber = (valueStr, localizedDigits) => {\n  const nonLocalizedValueStr = removeLocalizedDigits(valueStr, localizedDigits);\n  // `Number(' ')` returns `0` even if ' ' is not a valid number.\n  return nonLocalizedValueStr !== ' ' && !Number.isNaN(Number(nonLocalizedValueStr));\n};\n\n/**\n * Remove the leading zeroes to a digit section value.\n * E.g.: `03` => `3`\n * Warning: Should only be called with non-localized digits. Call `removeLocalizedDigits` with your value if needed.\n */\nexports.isStringNumber = isStringNumber;\nconst cleanLeadingZeros = (valueStr, size) => {\n  let cleanValueStr = valueStr;\n\n  // Remove the leading zeros\n  cleanValueStr = Number(cleanValueStr).toString();\n\n  // Add enough leading zeros to fill the section\n  while (cleanValueStr.length < size) {\n    cleanValueStr = `0${cleanValueStr}`;\n  }\n  return cleanValueStr;\n};\nexports.cleanLeadingZeros = cleanLeadingZeros;\nconst cleanDigitSectionValue = (utils, value, sectionBoundaries, localizedDigits, section) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (section.type !== 'day' && section.contentType === 'digit-with-letter') {\n      throw new Error([`MUI X: The token \"${section.format}\" is a digit format with letter in it.'\n             This type of format is only supported for 'day' sections`].join('\\n'));\n    }\n  }\n  if (section.type === 'day' && section.contentType === 'digit-with-letter') {\n    const date = utils.setDate(sectionBoundaries.longestMonth, value);\n    return utils.formatByString(date, section.format);\n  }\n\n  // queryValue without leading `0` (`01` => `1`)\n  let valueStr = value.toString();\n  if (section.hasLeadingZerosInInput) {\n    valueStr = cleanLeadingZeros(valueStr, section.maxLength);\n  }\n  return applyLocalizedDigits(valueStr, localizedDigits);\n};\nexports.cleanDigitSectionValue = cleanDigitSectionValue;\nconst adjustSectionValue = (utils, timezone, section, keyCode, sectionsValueBoundaries, localizedDigits, activeDate, stepsAttributes) => {\n  const delta = getDeltaFromKeyCode(keyCode);\n  const isStart = keyCode === 'Home';\n  const isEnd = keyCode === 'End';\n  const shouldSetAbsolute = section.value === '' || isStart || isEnd;\n  const adjustDigitSection = () => {\n    const sectionBoundaries = sectionsValueBoundaries[section.type]({\n      currentDate: activeDate,\n      format: section.format,\n      contentType: section.contentType\n    });\n    const getCleanValue = value => cleanDigitSectionValue(utils, value, sectionBoundaries, localizedDigits, section);\n    const step = section.type === 'minutes' && stepsAttributes?.minutesStep ? stepsAttributes.minutesStep : 1;\n    let newSectionValueNumber;\n    if (shouldSetAbsolute) {\n      if (section.type === 'year' && !isEnd && !isStart) {\n        return utils.formatByString(utils.date(undefined, timezone), section.format);\n      }\n      if (delta > 0 || isStart) {\n        newSectionValueNumber = sectionBoundaries.minimum;\n      } else {\n        newSectionValueNumber = sectionBoundaries.maximum;\n      }\n    } else {\n      const currentSectionValue = parseInt(removeLocalizedDigits(section.value, localizedDigits), 10);\n      newSectionValueNumber = currentSectionValue + delta * step;\n    }\n    if (newSectionValueNumber % step !== 0) {\n      if (delta < 0 || isStart) {\n        newSectionValueNumber += step - (step + newSectionValueNumber) % step; // for JS -3 % 5 = -3 (should be 2)\n      }\n      if (delta > 0 || isEnd) {\n        newSectionValueNumber -= newSectionValueNumber % step;\n      }\n    }\n    if (newSectionValueNumber > sectionBoundaries.maximum) {\n      return getCleanValue(sectionBoundaries.minimum + (newSectionValueNumber - sectionBoundaries.maximum - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));\n    }\n    if (newSectionValueNumber < sectionBoundaries.minimum) {\n      return getCleanValue(sectionBoundaries.maximum - (sectionBoundaries.minimum - newSectionValueNumber - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));\n    }\n    return getCleanValue(newSectionValueNumber);\n  };\n  const adjustLetterSection = () => {\n    const options = getLetterEditingOptions(utils, timezone, section.type, section.format);\n    if (options.length === 0) {\n      return section.value;\n    }\n    if (shouldSetAbsolute) {\n      if (delta > 0 || isStart) {\n        return options[0];\n      }\n      return options[options.length - 1];\n    }\n    const currentOptionIndex = options.indexOf(section.value);\n    const newOptionIndex = (currentOptionIndex + delta) % options.length;\n    const clampedIndex = (newOptionIndex + options.length) % options.length;\n    return options[clampedIndex];\n  };\n  if (section.contentType === 'digit' || section.contentType === 'digit-with-letter') {\n    return adjustDigitSection();\n  }\n  return adjustLetterSection();\n};\nexports.adjustSectionValue = adjustSectionValue;\nconst getSectionVisibleValue = (section, target, localizedDigits) => {\n  let value = section.value || section.placeholder;\n  const hasLeadingZeros = target === 'non-input' ? section.hasLeadingZerosInFormat : section.hasLeadingZerosInInput;\n  if (target === 'non-input' && section.hasLeadingZerosInInput && !section.hasLeadingZerosInFormat) {\n    value = Number(removeLocalizedDigits(value, localizedDigits)).toString();\n  }\n\n  // In the input, we add an empty character at the end of each section without leading zeros.\n  // This makes sure that `onChange` will always be fired.\n  // Otherwise, when your input value equals `1/dd/yyyy` (format `M/DD/YYYY` on DayJs),\n  // If you press `1`, on the first section, the new value is also `1/dd/yyyy`,\n  // So the browser will not fire the input `onChange`.\n  const shouldAddInvisibleSpace = ['input-rtl', 'input-ltr'].includes(target) && section.contentType === 'digit' && !hasLeadingZeros && value.length === 1;\n  if (shouldAddInvisibleSpace) {\n    value = `${value}\\u200e`;\n  }\n  if (target === 'input-rtl') {\n    value = `\\u2068${value}\\u2069`;\n  }\n  return value;\n};\nexports.getSectionVisibleValue = getSectionVisibleValue;\nconst changeSectionValueFormat = (utils, valueStr, currentFormat, newFormat) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (getDateSectionConfigFromFormatToken(utils, currentFormat).type === 'weekDay') {\n      throw new Error(\"changeSectionValueFormat doesn't support week day formats\");\n    }\n  }\n  return utils.formatByString(utils.parse(valueStr, currentFormat), newFormat);\n};\nexports.changeSectionValueFormat = changeSectionValueFormat;\nconst isFourDigitYearFormat = (utils, format) => utils.formatByString(utils.date(undefined, 'system'), format).length === 4;\nconst doesSectionFormatHaveLeadingZeros = (utils, contentType, sectionType, format) => {\n  if (contentType !== 'digit') {\n    return false;\n  }\n  const now = utils.date(undefined, 'default');\n  switch (sectionType) {\n    // We can't use `changeSectionValueFormat`, because  `utils.parse('1', 'YYYY')` returns `1971` instead of `1`.\n    case 'year':\n      {\n        // Remove once https://github.com/iamkun/dayjs/pull/2847 is merged and bump dayjs version\n        if (utils.lib === 'dayjs' && format === 'YY') {\n          return true;\n        }\n        return utils.formatByString(utils.setYear(now, 1), format).startsWith('0');\n      }\n    case 'month':\n      {\n        return utils.formatByString(utils.startOfYear(now), format).length > 1;\n      }\n    case 'day':\n      {\n        return utils.formatByString(utils.startOfMonth(now), format).length > 1;\n      }\n    case 'weekDay':\n      {\n        return utils.formatByString(utils.startOfWeek(now), format).length > 1;\n      }\n    case 'hours':\n      {\n        return utils.formatByString(utils.setHours(now, 1), format).length > 1;\n      }\n    case 'minutes':\n      {\n        return utils.formatByString(utils.setMinutes(now, 1), format).length > 1;\n      }\n    case 'seconds':\n      {\n        return utils.formatByString(utils.setSeconds(now, 1), format).length > 1;\n      }\n    default:\n      {\n        throw new Error('Invalid section type');\n      }\n  }\n};\n\n/**\n * Some date libraries like `dayjs` don't support parsing from date with escaped characters.\n * To make sure that the parsing works, we are building a format and a date without any separator.\n */\nexports.doesSectionFormatHaveLeadingZeros = doesSectionFormatHaveLeadingZeros;\nconst getDateFromDateSections = (utils, sections, localizedDigits) => {\n  // If we have both a day and a weekDay section,\n  // Then we skip the weekDay in the parsing because libraries like dayjs can't parse complicated formats containing a weekDay.\n  // dayjs(dayjs().format('dddd MMMM D YYYY'), 'dddd MMMM D YYYY')) // returns `Invalid Date` even if the format is valid.\n  const shouldSkipWeekDays = sections.some(section => section.type === 'day');\n  const sectionFormats = [];\n  const sectionValues = [];\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const shouldSkip = shouldSkipWeekDays && section.type === 'weekDay';\n    if (!shouldSkip) {\n      sectionFormats.push(section.format);\n      sectionValues.push(getSectionVisibleValue(section, 'non-input', localizedDigits));\n    }\n  }\n  const formatWithoutSeparator = sectionFormats.join(' ');\n  const dateWithoutSeparatorStr = sectionValues.join(' ');\n  return utils.parse(dateWithoutSeparatorStr, formatWithoutSeparator);\n};\nexports.getDateFromDateSections = getDateFromDateSections;\nconst createDateStrForV7HiddenInputFromSections = sections => sections.map(section => {\n  return `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`;\n}).join('');\nexports.createDateStrForV7HiddenInputFromSections = createDateStrForV7HiddenInputFromSections;\nconst createDateStrForV6InputFromSections = (sections, localizedDigits, isRtl) => {\n  const formattedSections = sections.map(section => {\n    const dateValue = getSectionVisibleValue(section, isRtl ? 'input-rtl' : 'input-ltr', localizedDigits);\n    return `${section.startSeparator}${dateValue}${section.endSeparator}`;\n  });\n  const dateStr = formattedSections.join('');\n  if (!isRtl) {\n    return dateStr;\n  }\n\n  // \\u2066: start left-to-right isolation\n  // \\u2067: start right-to-left isolation\n  // \\u2068: start first strong character isolation\n  // \\u2069: pop isolation\n  // wrap into an isolated group such that separators can split the string in smaller ones by adding \\u2069\\u2068\n  return `\\u2066${dateStr}\\u2069`;\n};\nexports.createDateStrForV6InputFromSections = createDateStrForV6InputFromSections;\nconst getSectionsBoundaries = (utils, localizedDigits, timezone) => {\n  const today = utils.date(undefined, timezone);\n  const endOfYear = utils.endOfYear(today);\n  const endOfDay = utils.endOfDay(today);\n  const {\n    maxDaysInMonth,\n    longestMonth\n  } = (0, _dateUtils.getMonthsInYear)(utils, today).reduce((acc, month) => {\n    const daysInMonth = utils.getDaysInMonth(month);\n    if (daysInMonth > acc.maxDaysInMonth) {\n      return {\n        maxDaysInMonth: daysInMonth,\n        longestMonth: month\n      };\n    }\n    return acc;\n  }, {\n    maxDaysInMonth: 0,\n    longestMonth: null\n  });\n  return {\n    year: ({\n      format\n    }) => ({\n      minimum: 0,\n      maximum: isFourDigitYearFormat(utils, format) ? 9999 : 99\n    }),\n    month: () => ({\n      minimum: 1,\n      // Assumption: All years have the same amount of months\n      maximum: utils.getMonth(endOfYear) + 1\n    }),\n    day: ({\n      currentDate\n    }) => ({\n      minimum: 1,\n      maximum: currentDate != null && utils.isValid(currentDate) ? utils.getDaysInMonth(currentDate) : maxDaysInMonth,\n      longestMonth: longestMonth\n    }),\n    weekDay: ({\n      format,\n      contentType\n    }) => {\n      if (contentType === 'digit') {\n        const daysInWeek = getDaysInWeekStr(utils, format).map(Number);\n        return {\n          minimum: Math.min(...daysInWeek),\n          maximum: Math.max(...daysInWeek)\n        };\n      }\n      return {\n        minimum: 1,\n        maximum: 7\n      };\n    },\n    hours: ({\n      format\n    }) => {\n      const lastHourInDay = utils.getHours(endOfDay);\n      const hasMeridiem = removeLocalizedDigits(utils.formatByString(utils.endOfDay(today), format), localizedDigits) !== lastHourInDay.toString();\n      if (hasMeridiem) {\n        return {\n          minimum: 1,\n          maximum: Number(removeLocalizedDigits(utils.formatByString(utils.startOfDay(today), format), localizedDigits))\n        };\n      }\n      return {\n        minimum: 0,\n        maximum: lastHourInDay\n      };\n    },\n    minutes: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of minutes\n      maximum: utils.getMinutes(endOfDay)\n    }),\n    seconds: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of seconds\n      maximum: utils.getSeconds(endOfDay)\n    }),\n    meridiem: () => ({\n      minimum: 0,\n      maximum: 1\n    }),\n    empty: () => ({\n      minimum: 0,\n      maximum: 0\n    })\n  };\n};\nexports.getSectionsBoundaries = getSectionsBoundaries;\nlet warnedOnceInvalidSection = false;\nconst validateSections = (sections, valueType) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!warnedOnceInvalidSection) {\n      const supportedSections = ['empty'];\n      if (['date', 'date-time'].includes(valueType)) {\n        supportedSections.push('weekDay', 'day', 'month', 'year');\n      }\n      if (['time', 'date-time'].includes(valueType)) {\n        supportedSections.push('hours', 'minutes', 'seconds', 'meridiem');\n      }\n      const invalidSection = sections.find(section => !supportedSections.includes(section.type));\n      if (invalidSection) {\n        console.warn(`MUI X: The field component you are using is not compatible with the \"${invalidSection.type}\" date section.`, `The supported date sections are [\"${supportedSections.join('\", \"')}\"]\\`.`);\n        warnedOnceInvalidSection = true;\n      }\n    }\n  }\n};\nexports.validateSections = validateSections;\nconst transferDateSectionValue = (utils, section, dateToTransferFrom, dateToTransferTo) => {\n  switch (section.type) {\n    case 'year':\n      {\n        return utils.setYear(dateToTransferTo, utils.getYear(dateToTransferFrom));\n      }\n    case 'month':\n      {\n        return utils.setMonth(dateToTransferTo, utils.getMonth(dateToTransferFrom));\n      }\n    case 'weekDay':\n      {\n        const formattedDaysInWeek = getDaysInWeekStr(utils, section.format);\n        const dayInWeekStrOfActiveDate = utils.formatByString(dateToTransferFrom, section.format);\n        const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);\n        const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);\n        const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;\n        return utils.addDays(dateToTransferFrom, diff);\n      }\n    case 'day':\n      {\n        return utils.setDate(dateToTransferTo, utils.getDate(dateToTransferFrom));\n      }\n    case 'meridiem':\n      {\n        const isAM = utils.getHours(dateToTransferFrom) < 12;\n        const mergedDateHours = utils.getHours(dateToTransferTo);\n        if (isAM && mergedDateHours >= 12) {\n          return utils.addHours(dateToTransferTo, -12);\n        }\n        if (!isAM && mergedDateHours < 12) {\n          return utils.addHours(dateToTransferTo, 12);\n        }\n        return dateToTransferTo;\n      }\n    case 'hours':\n      {\n        return utils.setHours(dateToTransferTo, utils.getHours(dateToTransferFrom));\n      }\n    case 'minutes':\n      {\n        return utils.setMinutes(dateToTransferTo, utils.getMinutes(dateToTransferFrom));\n      }\n    case 'seconds':\n      {\n        return utils.setSeconds(dateToTransferTo, utils.getSeconds(dateToTransferFrom));\n      }\n    default:\n      {\n        return dateToTransferTo;\n      }\n  }\n};\nconst reliableSectionModificationOrder = {\n  year: 1,\n  month: 2,\n  day: 3,\n  weekDay: 4,\n  hours: 5,\n  minutes: 6,\n  seconds: 7,\n  meridiem: 8,\n  empty: 9\n};\nconst mergeDateIntoReferenceDate = (utils, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) =>\n// cloning sections before sort to avoid mutating it\n[...sections].sort((a, b) => reliableSectionModificationOrder[a.type] - reliableSectionModificationOrder[b.type]).reduce((mergedDate, section) => {\n  if (!shouldLimitToEditedSections || section.modified) {\n    return transferDateSectionValue(utils, section, dateToTransferFrom, mergedDate);\n  }\n  return mergedDate;\n}, referenceDate);\nexports.mergeDateIntoReferenceDate = mergeDateIntoReferenceDate;\nconst isAndroid = () => navigator.userAgent.toLowerCase().includes('android');\n\n// TODO v8: Remove if we drop the v6 TextField approach.\nexports.isAndroid = isAndroid;\nconst getSectionOrder = (sections, shouldApplyRTL) => {\n  const neighbors = {};\n  if (!shouldApplyRTL) {\n    sections.forEach((_, index) => {\n      const leftIndex = index === 0 ? null : index - 1;\n      const rightIndex = index === sections.length - 1 ? null : index + 1;\n      neighbors[index] = {\n        leftIndex,\n        rightIndex\n      };\n    });\n    return {\n      neighbors,\n      startIndex: 0,\n      endIndex: sections.length - 1\n    };\n  }\n  const rtl2ltr = {};\n  const ltr2rtl = {};\n  let groupedSectionsStart = 0;\n  let groupedSectionsEnd = 0;\n  let RTLIndex = sections.length - 1;\n  while (RTLIndex >= 0) {\n    groupedSectionsEnd = sections.findIndex(\n    // eslint-disable-next-line @typescript-eslint/no-loop-func\n    (section, index) => index >= groupedSectionsStart && section.endSeparator?.includes(' ') &&\n    // Special case where the spaces were not there in the initial input\n    section.endSeparator !== ' / ');\n    if (groupedSectionsEnd === -1) {\n      groupedSectionsEnd = sections.length - 1;\n    }\n    for (let i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {\n      ltr2rtl[i] = RTLIndex;\n      rtl2ltr[RTLIndex] = i;\n      RTLIndex -= 1;\n    }\n    groupedSectionsStart = groupedSectionsEnd + 1;\n  }\n  sections.forEach((_, index) => {\n    const rtlIndex = ltr2rtl[index];\n    const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];\n    const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];\n    neighbors[index] = {\n      leftIndex,\n      rightIndex\n    };\n  });\n  return {\n    neighbors,\n    startIndex: rtl2ltr[0],\n    endIndex: rtl2ltr[sections.length - 1]\n  };\n};\nexports.getSectionOrder = getSectionOrder;\nconst parseSelectedSections = (selectedSections, sections) => {\n  if (selectedSections == null) {\n    return null;\n  }\n  if (selectedSections === 'all') {\n    return 'all';\n  }\n  if (typeof selectedSections === 'string') {\n    const index = sections.findIndex(section => section.type === selectedSections);\n    return index === -1 ? null : index;\n  }\n  return selectedSections;\n};\nexports.parseSelectedSections = parseSelectedSections;\nconst getSectionValueText = (section, utils) => {\n  if (!section.value) {\n    return undefined;\n  }\n  switch (section.type) {\n    case 'month':\n      {\n        if (section.contentType === 'digit') {\n          return utils.format(utils.setMonth(utils.date(), Number(section.value) - 1), 'month');\n        }\n        const parsedDate = utils.parse(section.value, section.format);\n        return parsedDate ? utils.format(parsedDate, 'month') : undefined;\n      }\n    case 'day':\n      return section.contentType === 'digit' ? utils.format(utils.setDate(utils.startOfYear(utils.date()), Number(section.value)), 'dayOfMonthFull') : section.value;\n    case 'weekDay':\n      // TODO: improve by providing the label of the week day\n      return undefined;\n    default:\n      return undefined;\n  }\n};\nexports.getSectionValueText = getSectionValueText;\nconst getSectionValueNow = (section, utils) => {\n  if (!section.value) {\n    return undefined;\n  }\n  switch (section.type) {\n    case 'weekDay':\n      {\n        if (section.contentType === 'letter') {\n          // TODO: improve by resolving the week day number from a letter week day\n          return undefined;\n        }\n        return Number(section.value);\n      }\n    case 'meridiem':\n      {\n        const parsedDate = utils.parse(`01:00 ${section.value}`, `${utils.formats.hours12h}:${utils.formats.minutes} ${section.format}`);\n        if (parsedDate) {\n          return utils.getHours(parsedDate) >= 12 ? 1 : 0;\n        }\n        return undefined;\n      }\n    case 'day':\n      return section.contentType === 'digit-with-letter' ? parseInt(section.value, 10) : Number(section.value);\n    case 'month':\n      {\n        if (section.contentType === 'digit') {\n          return Number(section.value);\n        }\n        const parsedDate = utils.parse(section.value, section.format);\n        return parsedDate ? utils.getMonth(parsedDate) + 1 : undefined;\n      }\n    default:\n      return section.contentType !== 'letter' ? Number(section.value) : undefined;\n  }\n};\nexports.getSectionValueNow = getSectionValueNow;","map":{"version":3,"names":["Object","defineProperty","exports","value","validateSections","removeLocalizedDigits","parseSelectedSections","mergeDateIntoReferenceDate","isStringNumber","isAndroid","getSectionsBoundaries","getSectionVisibleValue","getSectionValueText","getSectionValueNow","getSectionOrder","getLocalizedDigits","getLetterEditingOptions","getDaysInWeekStr","getDateSectionConfigFromFormatToken","getDateFromDateSections","doesSectionFormatHaveLeadingZeros","createDateStrForV7HiddenInputFromSections","createDateStrForV6InputFromSections","cleanLeadingZeros","cleanDigitSectionValue","changeSectionValueFormat","applyLocalizedDigits","adjustSectionValue","FORMAT_SECONDS_NO_LEADING_ZEROS","_dateUtils","require","utils","formatToken","config","formatTokenMap","Error","join","type","contentType","maxLength","undefined","sectionType","getDeltaFromKeyCode","keyCode","format","elements","now","date","startDate","startOfWeek","endDate","endOfWeek","current","isBefore","push","addDays","map","weekDay","formatByString","timezone","getMonthsInYear","month","startOfDay","endOfDay","NON_LOCALIZED_DIGITS","today","formattedZero","setSeconds","Array","from","length","_","index","valueStr","localizedDigits","digits","currentFormattedDigit","i","matchingDigitIndex","indexOf","toString","split","char","Number","nonLocalizedValueStr","isNaN","size","cleanValueStr","sectionBoundaries","section","process","env","NODE_ENV","setDate","longestMonth","hasLeadingZerosInInput","sectionsValueBoundaries","activeDate","stepsAttributes","delta","isStart","isEnd","shouldSetAbsolute","adjustDigitSection","currentDate","getCleanValue","step","minutesStep","newSectionValueNumber","minimum","maximum","currentSectionValue","parseInt","adjustLetterSection","options","currentOptionIndex","newOptionIndex","clampedIndex","target","placeholder","hasLeadingZeros","hasLeadingZerosInFormat","shouldAddInvisibleSpace","includes","currentFormat","newFormat","parse","isFourDigitYearFormat","lib","setYear","startsWith","startOfYear","startOfMonth","setHours","setMinutes","sections","shouldSkipWeekDays","some","sectionFormats","sectionValues","shouldSkip","formatWithoutSeparator","dateWithoutSeparatorStr","startSeparator","endSeparator","isRtl","formattedSections","dateValue","dateStr","endOfYear","maxDaysInMonth","reduce","acc","daysInMonth","getDaysInMonth","year","getMonth","day","isValid","daysInWeek","Math","min","max","hours","lastHourInDay","getHours","hasMeridiem","minutes","getMinutes","seconds","getSeconds","meridiem","empty","warnedOnceInvalidSection","valueType","supportedSections","invalidSection","find","console","warn","transferDateSectionValue","dateToTransferFrom","dateToTransferTo","getYear","setMonth","formattedDaysInWeek","dayInWeekStrOfActiveDate","dayInWeekOfActiveDate","dayInWeekOfNewSectionValue","diff","getDate","isAM","mergedDateHours","addHours","reliableSectionModificationOrder","referenceDate","shouldLimitToEditedSections","sort","a","b","mergedDate","modified","navigator","userAgent","toLowerCase","shouldApplyRTL","neighbors","forEach","leftIndex","rightIndex","startIndex","endIndex","rtl2ltr","ltr2rtl","groupedSectionsStart","groupedSectionsEnd","RTLIndex","findIndex","rtlIndex","selectedSections","parsedDate","formats","hours12h"],"sources":["C:/Users/LENOVO/Desktop/spitalmanagement/node_modules/@mui/x-date-pickers/node/internals/hooks/useField/useField.utils.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateSections = exports.removeLocalizedDigits = exports.parseSelectedSections = exports.mergeDateIntoReferenceDate = exports.isStringNumber = exports.isAndroid = exports.getSectionsBoundaries = exports.getSectionVisibleValue = exports.getSectionValueText = exports.getSectionValueNow = exports.getSectionOrder = exports.getLocalizedDigits = exports.getLetterEditingOptions = exports.getDaysInWeekStr = exports.getDateSectionConfigFromFormatToken = exports.getDateFromDateSections = exports.doesSectionFormatHaveLeadingZeros = exports.createDateStrForV7HiddenInputFromSections = exports.createDateStrForV6InputFromSections = exports.cleanLeadingZeros = exports.cleanDigitSectionValue = exports.changeSectionValueFormat = exports.applyLocalizedDigits = exports.adjustSectionValue = exports.FORMAT_SECONDS_NO_LEADING_ZEROS = void 0;\nvar _dateUtils = require(\"../../utils/date-utils\");\nconst getDateSectionConfigFromFormatToken = (utils, formatToken) => {\n  const config = utils.formatTokenMap[formatToken];\n  if (config == null) {\n    throw new Error([`MUI X: The token \"${formatToken}\" is not supported by the Date and Time Pickers.`, 'Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported.'].join('\\n'));\n  }\n  if (typeof config === 'string') {\n    return {\n      type: config,\n      contentType: config === 'meridiem' ? 'letter' : 'digit',\n      maxLength: undefined\n    };\n  }\n  return {\n    type: config.sectionType,\n    contentType: config.contentType,\n    maxLength: config.maxLength\n  };\n};\nexports.getDateSectionConfigFromFormatToken = getDateSectionConfigFromFormatToken;\nconst getDeltaFromKeyCode = keyCode => {\n  switch (keyCode) {\n    case 'ArrowUp':\n      return 1;\n    case 'ArrowDown':\n      return -1;\n    case 'PageUp':\n      return 5;\n    case 'PageDown':\n      return -5;\n    default:\n      return 0;\n  }\n};\nconst getDaysInWeekStr = (utils, format) => {\n  const elements = [];\n  const now = utils.date(undefined, 'default');\n  const startDate = utils.startOfWeek(now);\n  const endDate = utils.endOfWeek(now);\n  let current = startDate;\n  while (utils.isBefore(current, endDate)) {\n    elements.push(current);\n    current = utils.addDays(current, 1);\n  }\n  return elements.map(weekDay => utils.formatByString(weekDay, format));\n};\nexports.getDaysInWeekStr = getDaysInWeekStr;\nconst getLetterEditingOptions = (utils, timezone, sectionType, format) => {\n  switch (sectionType) {\n    case 'month':\n      {\n        return (0, _dateUtils.getMonthsInYear)(utils, utils.date(undefined, timezone)).map(month => utils.formatByString(month, format));\n      }\n    case 'weekDay':\n      {\n        return getDaysInWeekStr(utils, format);\n      }\n    case 'meridiem':\n      {\n        const now = utils.date(undefined, timezone);\n        return [utils.startOfDay(now), utils.endOfDay(now)].map(date => utils.formatByString(date, format));\n      }\n    default:\n      {\n        return [];\n      }\n  }\n};\n\n// This format should be the same on all the adapters\n// If some adapter does not respect this convention, then we will need to hardcode the format on each adapter.\nexports.getLetterEditingOptions = getLetterEditingOptions;\nconst FORMAT_SECONDS_NO_LEADING_ZEROS = exports.FORMAT_SECONDS_NO_LEADING_ZEROS = 's';\nconst NON_LOCALIZED_DIGITS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];\nconst getLocalizedDigits = utils => {\n  const today = utils.date(undefined);\n  const formattedZero = utils.formatByString(utils.setSeconds(today, 0), FORMAT_SECONDS_NO_LEADING_ZEROS);\n  if (formattedZero === '0') {\n    return NON_LOCALIZED_DIGITS;\n  }\n  return Array.from({\n    length: 10\n  }).map((_, index) => utils.formatByString(utils.setSeconds(today, index), FORMAT_SECONDS_NO_LEADING_ZEROS));\n};\nexports.getLocalizedDigits = getLocalizedDigits;\nconst removeLocalizedDigits = (valueStr, localizedDigits) => {\n  if (localizedDigits[0] === '0') {\n    return valueStr;\n  }\n  const digits = [];\n  let currentFormattedDigit = '';\n  for (let i = 0; i < valueStr.length; i += 1) {\n    currentFormattedDigit += valueStr[i];\n    const matchingDigitIndex = localizedDigits.indexOf(currentFormattedDigit);\n    if (matchingDigitIndex > -1) {\n      digits.push(matchingDigitIndex.toString());\n      currentFormattedDigit = '';\n    }\n  }\n  return digits.join('');\n};\nexports.removeLocalizedDigits = removeLocalizedDigits;\nconst applyLocalizedDigits = (valueStr, localizedDigits) => {\n  if (localizedDigits[0] === '0') {\n    return valueStr;\n  }\n  return valueStr.split('').map(char => localizedDigits[Number(char)]).join('');\n};\nexports.applyLocalizedDigits = applyLocalizedDigits;\nconst isStringNumber = (valueStr, localizedDigits) => {\n  const nonLocalizedValueStr = removeLocalizedDigits(valueStr, localizedDigits);\n  // `Number(' ')` returns `0` even if ' ' is not a valid number.\n  return nonLocalizedValueStr !== ' ' && !Number.isNaN(Number(nonLocalizedValueStr));\n};\n\n/**\n * Remove the leading zeroes to a digit section value.\n * E.g.: `03` => `3`\n * Warning: Should only be called with non-localized digits. Call `removeLocalizedDigits` with your value if needed.\n */\nexports.isStringNumber = isStringNumber;\nconst cleanLeadingZeros = (valueStr, size) => {\n  let cleanValueStr = valueStr;\n\n  // Remove the leading zeros\n  cleanValueStr = Number(cleanValueStr).toString();\n\n  // Add enough leading zeros to fill the section\n  while (cleanValueStr.length < size) {\n    cleanValueStr = `0${cleanValueStr}`;\n  }\n  return cleanValueStr;\n};\nexports.cleanLeadingZeros = cleanLeadingZeros;\nconst cleanDigitSectionValue = (utils, value, sectionBoundaries, localizedDigits, section) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (section.type !== 'day' && section.contentType === 'digit-with-letter') {\n      throw new Error([`MUI X: The token \"${section.format}\" is a digit format with letter in it.'\n             This type of format is only supported for 'day' sections`].join('\\n'));\n    }\n  }\n  if (section.type === 'day' && section.contentType === 'digit-with-letter') {\n    const date = utils.setDate(sectionBoundaries.longestMonth, value);\n    return utils.formatByString(date, section.format);\n  }\n\n  // queryValue without leading `0` (`01` => `1`)\n  let valueStr = value.toString();\n  if (section.hasLeadingZerosInInput) {\n    valueStr = cleanLeadingZeros(valueStr, section.maxLength);\n  }\n  return applyLocalizedDigits(valueStr, localizedDigits);\n};\nexports.cleanDigitSectionValue = cleanDigitSectionValue;\nconst adjustSectionValue = (utils, timezone, section, keyCode, sectionsValueBoundaries, localizedDigits, activeDate, stepsAttributes) => {\n  const delta = getDeltaFromKeyCode(keyCode);\n  const isStart = keyCode === 'Home';\n  const isEnd = keyCode === 'End';\n  const shouldSetAbsolute = section.value === '' || isStart || isEnd;\n  const adjustDigitSection = () => {\n    const sectionBoundaries = sectionsValueBoundaries[section.type]({\n      currentDate: activeDate,\n      format: section.format,\n      contentType: section.contentType\n    });\n    const getCleanValue = value => cleanDigitSectionValue(utils, value, sectionBoundaries, localizedDigits, section);\n    const step = section.type === 'minutes' && stepsAttributes?.minutesStep ? stepsAttributes.minutesStep : 1;\n    let newSectionValueNumber;\n    if (shouldSetAbsolute) {\n      if (section.type === 'year' && !isEnd && !isStart) {\n        return utils.formatByString(utils.date(undefined, timezone), section.format);\n      }\n      if (delta > 0 || isStart) {\n        newSectionValueNumber = sectionBoundaries.minimum;\n      } else {\n        newSectionValueNumber = sectionBoundaries.maximum;\n      }\n    } else {\n      const currentSectionValue = parseInt(removeLocalizedDigits(section.value, localizedDigits), 10);\n      newSectionValueNumber = currentSectionValue + delta * step;\n    }\n    if (newSectionValueNumber % step !== 0) {\n      if (delta < 0 || isStart) {\n        newSectionValueNumber += step - (step + newSectionValueNumber) % step; // for JS -3 % 5 = -3 (should be 2)\n      }\n      if (delta > 0 || isEnd) {\n        newSectionValueNumber -= newSectionValueNumber % step;\n      }\n    }\n    if (newSectionValueNumber > sectionBoundaries.maximum) {\n      return getCleanValue(sectionBoundaries.minimum + (newSectionValueNumber - sectionBoundaries.maximum - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));\n    }\n    if (newSectionValueNumber < sectionBoundaries.minimum) {\n      return getCleanValue(sectionBoundaries.maximum - (sectionBoundaries.minimum - newSectionValueNumber - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));\n    }\n    return getCleanValue(newSectionValueNumber);\n  };\n  const adjustLetterSection = () => {\n    const options = getLetterEditingOptions(utils, timezone, section.type, section.format);\n    if (options.length === 0) {\n      return section.value;\n    }\n    if (shouldSetAbsolute) {\n      if (delta > 0 || isStart) {\n        return options[0];\n      }\n      return options[options.length - 1];\n    }\n    const currentOptionIndex = options.indexOf(section.value);\n    const newOptionIndex = (currentOptionIndex + delta) % options.length;\n    const clampedIndex = (newOptionIndex + options.length) % options.length;\n    return options[clampedIndex];\n  };\n  if (section.contentType === 'digit' || section.contentType === 'digit-with-letter') {\n    return adjustDigitSection();\n  }\n  return adjustLetterSection();\n};\nexports.adjustSectionValue = adjustSectionValue;\nconst getSectionVisibleValue = (section, target, localizedDigits) => {\n  let value = section.value || section.placeholder;\n  const hasLeadingZeros = target === 'non-input' ? section.hasLeadingZerosInFormat : section.hasLeadingZerosInInput;\n  if (target === 'non-input' && section.hasLeadingZerosInInput && !section.hasLeadingZerosInFormat) {\n    value = Number(removeLocalizedDigits(value, localizedDigits)).toString();\n  }\n\n  // In the input, we add an empty character at the end of each section without leading zeros.\n  // This makes sure that `onChange` will always be fired.\n  // Otherwise, when your input value equals `1/dd/yyyy` (format `M/DD/YYYY` on DayJs),\n  // If you press `1`, on the first section, the new value is also `1/dd/yyyy`,\n  // So the browser will not fire the input `onChange`.\n  const shouldAddInvisibleSpace = ['input-rtl', 'input-ltr'].includes(target) && section.contentType === 'digit' && !hasLeadingZeros && value.length === 1;\n  if (shouldAddInvisibleSpace) {\n    value = `${value}\\u200e`;\n  }\n  if (target === 'input-rtl') {\n    value = `\\u2068${value}\\u2069`;\n  }\n  return value;\n};\nexports.getSectionVisibleValue = getSectionVisibleValue;\nconst changeSectionValueFormat = (utils, valueStr, currentFormat, newFormat) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (getDateSectionConfigFromFormatToken(utils, currentFormat).type === 'weekDay') {\n      throw new Error(\"changeSectionValueFormat doesn't support week day formats\");\n    }\n  }\n  return utils.formatByString(utils.parse(valueStr, currentFormat), newFormat);\n};\nexports.changeSectionValueFormat = changeSectionValueFormat;\nconst isFourDigitYearFormat = (utils, format) => utils.formatByString(utils.date(undefined, 'system'), format).length === 4;\nconst doesSectionFormatHaveLeadingZeros = (utils, contentType, sectionType, format) => {\n  if (contentType !== 'digit') {\n    return false;\n  }\n  const now = utils.date(undefined, 'default');\n  switch (sectionType) {\n    // We can't use `changeSectionValueFormat`, because  `utils.parse('1', 'YYYY')` returns `1971` instead of `1`.\n    case 'year':\n      {\n        // Remove once https://github.com/iamkun/dayjs/pull/2847 is merged and bump dayjs version\n        if (utils.lib === 'dayjs' && format === 'YY') {\n          return true;\n        }\n        return utils.formatByString(utils.setYear(now, 1), format).startsWith('0');\n      }\n    case 'month':\n      {\n        return utils.formatByString(utils.startOfYear(now), format).length > 1;\n      }\n    case 'day':\n      {\n        return utils.formatByString(utils.startOfMonth(now), format).length > 1;\n      }\n    case 'weekDay':\n      {\n        return utils.formatByString(utils.startOfWeek(now), format).length > 1;\n      }\n    case 'hours':\n      {\n        return utils.formatByString(utils.setHours(now, 1), format).length > 1;\n      }\n    case 'minutes':\n      {\n        return utils.formatByString(utils.setMinutes(now, 1), format).length > 1;\n      }\n    case 'seconds':\n      {\n        return utils.formatByString(utils.setSeconds(now, 1), format).length > 1;\n      }\n    default:\n      {\n        throw new Error('Invalid section type');\n      }\n  }\n};\n\n/**\n * Some date libraries like `dayjs` don't support parsing from date with escaped characters.\n * To make sure that the parsing works, we are building a format and a date without any separator.\n */\nexports.doesSectionFormatHaveLeadingZeros = doesSectionFormatHaveLeadingZeros;\nconst getDateFromDateSections = (utils, sections, localizedDigits) => {\n  // If we have both a day and a weekDay section,\n  // Then we skip the weekDay in the parsing because libraries like dayjs can't parse complicated formats containing a weekDay.\n  // dayjs(dayjs().format('dddd MMMM D YYYY'), 'dddd MMMM D YYYY')) // returns `Invalid Date` even if the format is valid.\n  const shouldSkipWeekDays = sections.some(section => section.type === 'day');\n  const sectionFormats = [];\n  const sectionValues = [];\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const shouldSkip = shouldSkipWeekDays && section.type === 'weekDay';\n    if (!shouldSkip) {\n      sectionFormats.push(section.format);\n      sectionValues.push(getSectionVisibleValue(section, 'non-input', localizedDigits));\n    }\n  }\n  const formatWithoutSeparator = sectionFormats.join(' ');\n  const dateWithoutSeparatorStr = sectionValues.join(' ');\n  return utils.parse(dateWithoutSeparatorStr, formatWithoutSeparator);\n};\nexports.getDateFromDateSections = getDateFromDateSections;\nconst createDateStrForV7HiddenInputFromSections = sections => sections.map(section => {\n  return `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`;\n}).join('');\nexports.createDateStrForV7HiddenInputFromSections = createDateStrForV7HiddenInputFromSections;\nconst createDateStrForV6InputFromSections = (sections, localizedDigits, isRtl) => {\n  const formattedSections = sections.map(section => {\n    const dateValue = getSectionVisibleValue(section, isRtl ? 'input-rtl' : 'input-ltr', localizedDigits);\n    return `${section.startSeparator}${dateValue}${section.endSeparator}`;\n  });\n  const dateStr = formattedSections.join('');\n  if (!isRtl) {\n    return dateStr;\n  }\n\n  // \\u2066: start left-to-right isolation\n  // \\u2067: start right-to-left isolation\n  // \\u2068: start first strong character isolation\n  // \\u2069: pop isolation\n  // wrap into an isolated group such that separators can split the string in smaller ones by adding \\u2069\\u2068\n  return `\\u2066${dateStr}\\u2069`;\n};\nexports.createDateStrForV6InputFromSections = createDateStrForV6InputFromSections;\nconst getSectionsBoundaries = (utils, localizedDigits, timezone) => {\n  const today = utils.date(undefined, timezone);\n  const endOfYear = utils.endOfYear(today);\n  const endOfDay = utils.endOfDay(today);\n  const {\n    maxDaysInMonth,\n    longestMonth\n  } = (0, _dateUtils.getMonthsInYear)(utils, today).reduce((acc, month) => {\n    const daysInMonth = utils.getDaysInMonth(month);\n    if (daysInMonth > acc.maxDaysInMonth) {\n      return {\n        maxDaysInMonth: daysInMonth,\n        longestMonth: month\n      };\n    }\n    return acc;\n  }, {\n    maxDaysInMonth: 0,\n    longestMonth: null\n  });\n  return {\n    year: ({\n      format\n    }) => ({\n      minimum: 0,\n      maximum: isFourDigitYearFormat(utils, format) ? 9999 : 99\n    }),\n    month: () => ({\n      minimum: 1,\n      // Assumption: All years have the same amount of months\n      maximum: utils.getMonth(endOfYear) + 1\n    }),\n    day: ({\n      currentDate\n    }) => ({\n      minimum: 1,\n      maximum: currentDate != null && utils.isValid(currentDate) ? utils.getDaysInMonth(currentDate) : maxDaysInMonth,\n      longestMonth: longestMonth\n    }),\n    weekDay: ({\n      format,\n      contentType\n    }) => {\n      if (contentType === 'digit') {\n        const daysInWeek = getDaysInWeekStr(utils, format).map(Number);\n        return {\n          minimum: Math.min(...daysInWeek),\n          maximum: Math.max(...daysInWeek)\n        };\n      }\n      return {\n        minimum: 1,\n        maximum: 7\n      };\n    },\n    hours: ({\n      format\n    }) => {\n      const lastHourInDay = utils.getHours(endOfDay);\n      const hasMeridiem = removeLocalizedDigits(utils.formatByString(utils.endOfDay(today), format), localizedDigits) !== lastHourInDay.toString();\n      if (hasMeridiem) {\n        return {\n          minimum: 1,\n          maximum: Number(removeLocalizedDigits(utils.formatByString(utils.startOfDay(today), format), localizedDigits))\n        };\n      }\n      return {\n        minimum: 0,\n        maximum: lastHourInDay\n      };\n    },\n    minutes: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of minutes\n      maximum: utils.getMinutes(endOfDay)\n    }),\n    seconds: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of seconds\n      maximum: utils.getSeconds(endOfDay)\n    }),\n    meridiem: () => ({\n      minimum: 0,\n      maximum: 1\n    }),\n    empty: () => ({\n      minimum: 0,\n      maximum: 0\n    })\n  };\n};\nexports.getSectionsBoundaries = getSectionsBoundaries;\nlet warnedOnceInvalidSection = false;\nconst validateSections = (sections, valueType) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!warnedOnceInvalidSection) {\n      const supportedSections = ['empty'];\n      if (['date', 'date-time'].includes(valueType)) {\n        supportedSections.push('weekDay', 'day', 'month', 'year');\n      }\n      if (['time', 'date-time'].includes(valueType)) {\n        supportedSections.push('hours', 'minutes', 'seconds', 'meridiem');\n      }\n      const invalidSection = sections.find(section => !supportedSections.includes(section.type));\n      if (invalidSection) {\n        console.warn(`MUI X: The field component you are using is not compatible with the \"${invalidSection.type}\" date section.`, `The supported date sections are [\"${supportedSections.join('\", \"')}\"]\\`.`);\n        warnedOnceInvalidSection = true;\n      }\n    }\n  }\n};\nexports.validateSections = validateSections;\nconst transferDateSectionValue = (utils, section, dateToTransferFrom, dateToTransferTo) => {\n  switch (section.type) {\n    case 'year':\n      {\n        return utils.setYear(dateToTransferTo, utils.getYear(dateToTransferFrom));\n      }\n    case 'month':\n      {\n        return utils.setMonth(dateToTransferTo, utils.getMonth(dateToTransferFrom));\n      }\n    case 'weekDay':\n      {\n        const formattedDaysInWeek = getDaysInWeekStr(utils, section.format);\n        const dayInWeekStrOfActiveDate = utils.formatByString(dateToTransferFrom, section.format);\n        const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);\n        const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);\n        const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;\n        return utils.addDays(dateToTransferFrom, diff);\n      }\n    case 'day':\n      {\n        return utils.setDate(dateToTransferTo, utils.getDate(dateToTransferFrom));\n      }\n    case 'meridiem':\n      {\n        const isAM = utils.getHours(dateToTransferFrom) < 12;\n        const mergedDateHours = utils.getHours(dateToTransferTo);\n        if (isAM && mergedDateHours >= 12) {\n          return utils.addHours(dateToTransferTo, -12);\n        }\n        if (!isAM && mergedDateHours < 12) {\n          return utils.addHours(dateToTransferTo, 12);\n        }\n        return dateToTransferTo;\n      }\n    case 'hours':\n      {\n        return utils.setHours(dateToTransferTo, utils.getHours(dateToTransferFrom));\n      }\n    case 'minutes':\n      {\n        return utils.setMinutes(dateToTransferTo, utils.getMinutes(dateToTransferFrom));\n      }\n    case 'seconds':\n      {\n        return utils.setSeconds(dateToTransferTo, utils.getSeconds(dateToTransferFrom));\n      }\n    default:\n      {\n        return dateToTransferTo;\n      }\n  }\n};\nconst reliableSectionModificationOrder = {\n  year: 1,\n  month: 2,\n  day: 3,\n  weekDay: 4,\n  hours: 5,\n  minutes: 6,\n  seconds: 7,\n  meridiem: 8,\n  empty: 9\n};\nconst mergeDateIntoReferenceDate = (utils, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) =>\n// cloning sections before sort to avoid mutating it\n[...sections].sort((a, b) => reliableSectionModificationOrder[a.type] - reliableSectionModificationOrder[b.type]).reduce((mergedDate, section) => {\n  if (!shouldLimitToEditedSections || section.modified) {\n    return transferDateSectionValue(utils, section, dateToTransferFrom, mergedDate);\n  }\n  return mergedDate;\n}, referenceDate);\nexports.mergeDateIntoReferenceDate = mergeDateIntoReferenceDate;\nconst isAndroid = () => navigator.userAgent.toLowerCase().includes('android');\n\n// TODO v8: Remove if we drop the v6 TextField approach.\nexports.isAndroid = isAndroid;\nconst getSectionOrder = (sections, shouldApplyRTL) => {\n  const neighbors = {};\n  if (!shouldApplyRTL) {\n    sections.forEach((_, index) => {\n      const leftIndex = index === 0 ? null : index - 1;\n      const rightIndex = index === sections.length - 1 ? null : index + 1;\n      neighbors[index] = {\n        leftIndex,\n        rightIndex\n      };\n    });\n    return {\n      neighbors,\n      startIndex: 0,\n      endIndex: sections.length - 1\n    };\n  }\n  const rtl2ltr = {};\n  const ltr2rtl = {};\n  let groupedSectionsStart = 0;\n  let groupedSectionsEnd = 0;\n  let RTLIndex = sections.length - 1;\n  while (RTLIndex >= 0) {\n    groupedSectionsEnd = sections.findIndex(\n    // eslint-disable-next-line @typescript-eslint/no-loop-func\n    (section, index) => index >= groupedSectionsStart && section.endSeparator?.includes(' ') &&\n    // Special case where the spaces were not there in the initial input\n    section.endSeparator !== ' / ');\n    if (groupedSectionsEnd === -1) {\n      groupedSectionsEnd = sections.length - 1;\n    }\n    for (let i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {\n      ltr2rtl[i] = RTLIndex;\n      rtl2ltr[RTLIndex] = i;\n      RTLIndex -= 1;\n    }\n    groupedSectionsStart = groupedSectionsEnd + 1;\n  }\n  sections.forEach((_, index) => {\n    const rtlIndex = ltr2rtl[index];\n    const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];\n    const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];\n    neighbors[index] = {\n      leftIndex,\n      rightIndex\n    };\n  });\n  return {\n    neighbors,\n    startIndex: rtl2ltr[0],\n    endIndex: rtl2ltr[sections.length - 1]\n  };\n};\nexports.getSectionOrder = getSectionOrder;\nconst parseSelectedSections = (selectedSections, sections) => {\n  if (selectedSections == null) {\n    return null;\n  }\n  if (selectedSections === 'all') {\n    return 'all';\n  }\n  if (typeof selectedSections === 'string') {\n    const index = sections.findIndex(section => section.type === selectedSections);\n    return index === -1 ? null : index;\n  }\n  return selectedSections;\n};\nexports.parseSelectedSections = parseSelectedSections;\nconst getSectionValueText = (section, utils) => {\n  if (!section.value) {\n    return undefined;\n  }\n  switch (section.type) {\n    case 'month':\n      {\n        if (section.contentType === 'digit') {\n          return utils.format(utils.setMonth(utils.date(), Number(section.value) - 1), 'month');\n        }\n        const parsedDate = utils.parse(section.value, section.format);\n        return parsedDate ? utils.format(parsedDate, 'month') : undefined;\n      }\n    case 'day':\n      return section.contentType === 'digit' ? utils.format(utils.setDate(utils.startOfYear(utils.date()), Number(section.value)), 'dayOfMonthFull') : section.value;\n    case 'weekDay':\n      // TODO: improve by providing the label of the week day\n      return undefined;\n    default:\n      return undefined;\n  }\n};\nexports.getSectionValueText = getSectionValueText;\nconst getSectionValueNow = (section, utils) => {\n  if (!section.value) {\n    return undefined;\n  }\n  switch (section.type) {\n    case 'weekDay':\n      {\n        if (section.contentType === 'letter') {\n          // TODO: improve by resolving the week day number from a letter week day\n          return undefined;\n        }\n        return Number(section.value);\n      }\n    case 'meridiem':\n      {\n        const parsedDate = utils.parse(`01:00 ${section.value}`, `${utils.formats.hours12h}:${utils.formats.minutes} ${section.format}`);\n        if (parsedDate) {\n          return utils.getHours(parsedDate) >= 12 ? 1 : 0;\n        }\n        return undefined;\n      }\n    case 'day':\n      return section.contentType === 'digit-with-letter' ? parseInt(section.value, 10) : Number(section.value);\n    case 'month':\n      {\n        if (section.contentType === 'digit') {\n          return Number(section.value);\n        }\n        const parsedDate = utils.parse(section.value, section.format);\n        return parsedDate ? utils.getMonth(parsedDate) + 1 : undefined;\n      }\n    default:\n      return section.contentType !== 'letter' ? Number(section.value) : undefined;\n  }\n};\nexports.getSectionValueNow = getSectionValueNow;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}