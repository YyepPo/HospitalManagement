{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useFieldV7TextField = void 0;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _useForkRef = _interopRequireDefault(require(\"@mui/utils/useForkRef\"));\nvar _useEventCallback = _interopRequireDefault(require(\"@mui/utils/useEventCallback\"));\nvar _useEnhancedEffect = _interopRequireDefault(require(\"@mui/utils/useEnhancedEffect\"));\nvar _useId = _interopRequireDefault(require(\"@mui/utils/useId\"));\nvar _useField = require(\"./useField.utils\");\nvar _utils = require(\"../../utils/utils\");\nvar _usePickersTranslations = require(\"../../../hooks/usePickersTranslations\");\nvar _useUtils = require(\"../useUtils\");\nconst useFieldV7TextField = params => {\n  const {\n    internalProps: {\n      disabled,\n      readOnly = false\n    },\n    forwardedProps: {\n      sectionListRef: inSectionListRef,\n      onBlur,\n      onClick,\n      onFocus,\n      onInput,\n      onPaste,\n      focused: focusedProp,\n      autoFocus = false\n    },\n    fieldValueManager,\n    applyCharacterEditing,\n    resetCharacterQuery,\n    setSelectedSections,\n    parsedSelectedSections,\n    state,\n    clearActiveSection,\n    clearValue,\n    updateSectionValue,\n    updateValueFromValueStr,\n    sectionOrder,\n    areAllSectionsEmpty,\n    sectionsValueBoundaries\n  } = params;\n  const sectionListRef = React.useRef(null);\n  const handleSectionListRef = (0, _useForkRef.default)(inSectionListRef, sectionListRef);\n  const translations = (0, _usePickersTranslations.usePickersTranslations)();\n  const utils = (0, _useUtils.useUtils)();\n  const id = (0, _useId.default)();\n  const [focused, setFocused] = React.useState(false);\n  const interactions = React.useMemo(() => ({\n    syncSelectionToDOM: () => {\n      if (!sectionListRef.current) {\n        return;\n      }\n      const selection = document.getSelection();\n      if (!selection) {\n        return;\n      }\n      if (parsedSelectedSections == null) {\n        // If the selection contains an element inside the field, we reset it.\n        if (selection.rangeCount > 0 && sectionListRef.current.getRoot().contains(selection.getRangeAt(0).startContainer)) {\n          selection.removeAllRanges();\n        }\n        if (focused) {\n          sectionListRef.current.getRoot().blur();\n        }\n        return;\n      }\n\n      // On multi input range pickers we want to update selection range only for the active input\n      if (!sectionListRef.current.getRoot().contains((0, _utils.getActiveElement)(document))) {\n        return;\n      }\n      const range = new window.Range();\n      let target;\n      if (parsedSelectedSections === 'all') {\n        target = sectionListRef.current.getRoot();\n      } else {\n        const section = state.sections[parsedSelectedSections];\n        if (section.type === 'empty') {\n          target = sectionListRef.current.getSectionContainer(parsedSelectedSections);\n        } else {\n          target = sectionListRef.current.getSectionContent(parsedSelectedSections);\n        }\n      }\n      range.selectNodeContents(target);\n      target.focus();\n      selection.removeAllRanges();\n      selection.addRange(range);\n    },\n    getActiveSectionIndexFromDOM: () => {\n      const activeElement = (0, _utils.getActiveElement)(document);\n      if (!activeElement || !sectionListRef.current || !sectionListRef.current.getRoot().contains(activeElement)) {\n        return null;\n      }\n      return sectionListRef.current.getSectionIndexFromDOMElement(activeElement);\n    },\n    focusField: (newSelectedSections = 0) => {\n      if (!sectionListRef.current ||\n      // if the field is already focused, we don't need to focus it again\n      interactions.getActiveSectionIndexFromDOM() != null) {\n        return;\n      }\n      const newParsedSelectedSections = (0, _useField.parseSelectedSections)(newSelectedSections, state.sections);\n      setFocused(true);\n      sectionListRef.current.getSectionContent(newParsedSelectedSections).focus();\n    },\n    setSelectedSections: newSelectedSections => {\n      if (!sectionListRef.current) {\n        return;\n      }\n      const newParsedSelectedSections = (0, _useField.parseSelectedSections)(newSelectedSections, state.sections);\n      const newActiveSectionIndex = newParsedSelectedSections === 'all' ? 0 : newParsedSelectedSections;\n      setFocused(newActiveSectionIndex !== null);\n      setSelectedSections(newSelectedSections);\n    },\n    isFieldFocused: () => {\n      const activeElement = (0, _utils.getActiveElement)(document);\n      return !!sectionListRef.current && sectionListRef.current.getRoot().contains(activeElement);\n    }\n  }), [parsedSelectedSections, setSelectedSections, state.sections, focused]);\n\n  /**\n   * If a section content has been updated with a value we don't want to keep,\n   * Then we need to imperatively revert it (we can't let React do it because the value did not change in his internal representation).\n   */\n  const revertDOMSectionChange = (0, _useEventCallback.default)(sectionIndex => {\n    if (!sectionListRef.current) {\n      return;\n    }\n    const section = state.sections[sectionIndex];\n    sectionListRef.current.getSectionContent(sectionIndex).innerHTML = section.value || section.placeholder;\n    interactions.syncSelectionToDOM();\n  });\n  const handleContainerClick = (0, _useEventCallback.default)((event, ...args) => {\n    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.\n    // We avoid this by checking if the call of `handleContainerClick` is actually intended, or a side effect.\n    if (event.isDefaultPrevented() || !sectionListRef.current) {\n      return;\n    }\n    setFocused(true);\n    onClick?.(event, ...args);\n    if (parsedSelectedSections === 'all') {\n      setTimeout(() => {\n        const cursorPosition = document.getSelection().getRangeAt(0).startOffset;\n        if (cursorPosition === 0) {\n          setSelectedSections(sectionOrder.startIndex);\n          return;\n        }\n        let sectionIndex = 0;\n        let cursorOnStartOfSection = 0;\n        while (cursorOnStartOfSection < cursorPosition && sectionIndex < state.sections.length) {\n          const section = state.sections[sectionIndex];\n          sectionIndex += 1;\n          cursorOnStartOfSection += `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`.length;\n        }\n        setSelectedSections(sectionIndex - 1);\n      });\n    } else if (!focused) {\n      setFocused(true);\n      setSelectedSections(sectionOrder.startIndex);\n    } else {\n      const hasClickedOnASection = sectionListRef.current.getRoot().contains(event.target);\n      if (!hasClickedOnASection) {\n        setSelectedSections(sectionOrder.startIndex);\n      }\n    }\n  });\n  const handleContainerInput = (0, _useEventCallback.default)(event => {\n    onInput?.(event);\n    if (!sectionListRef.current || parsedSelectedSections !== 'all') {\n      return;\n    }\n    const target = event.target;\n    const keyPressed = target.textContent ?? '';\n    sectionListRef.current.getRoot().innerHTML = state.sections.map(section => `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`).join('');\n    interactions.syncSelectionToDOM();\n    if (keyPressed.length === 0 || keyPressed.charCodeAt(0) === 10) {\n      resetCharacterQuery();\n      clearValue();\n      setSelectedSections('all');\n    } else if (keyPressed.length > 1) {\n      updateValueFromValueStr(keyPressed);\n    } else {\n      if (parsedSelectedSections === 'all') {\n        setSelectedSections(0);\n      }\n      applyCharacterEditing({\n        keyPressed,\n        sectionIndex: 0\n      });\n    }\n  });\n  const handleContainerPaste = (0, _useEventCallback.default)(event => {\n    onPaste?.(event);\n    if (readOnly || parsedSelectedSections !== 'all') {\n      event.preventDefault();\n      return;\n    }\n    const pastedValue = event.clipboardData.getData('text');\n    event.preventDefault();\n    resetCharacterQuery();\n    updateValueFromValueStr(pastedValue);\n  });\n  const handleContainerFocus = (0, _useEventCallback.default)((...args) => {\n    onFocus?.(...args);\n    if (focused || !sectionListRef.current) {\n      return;\n    }\n    setFocused(true);\n    const isFocusInsideASection = sectionListRef.current.getSectionIndexFromDOMElement((0, _utils.getActiveElement)(document)) != null;\n    if (!isFocusInsideASection) {\n      setSelectedSections(sectionOrder.startIndex);\n    }\n  });\n  const handleContainerBlur = (0, _useEventCallback.default)((...args) => {\n    onBlur?.(...args);\n    setTimeout(() => {\n      if (!sectionListRef.current) {\n        return;\n      }\n      const activeElement = (0, _utils.getActiveElement)(document);\n      const shouldBlur = !sectionListRef.current.getRoot().contains(activeElement);\n      if (shouldBlur) {\n        setFocused(false);\n        setSelectedSections(null);\n      }\n    });\n  });\n  const getInputContainerClickHandler = (0, _useEventCallback.default)(sectionIndex => event => {\n    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.\n    // We avoid this by checking if the call to this function is actually intended, or a side effect.\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n    setSelectedSections(sectionIndex);\n  });\n  const handleInputContentMouseUp = (0, _useEventCallback.default)(event => {\n    // Without this, the browser will remove the selected when clicking inside an already-selected section.\n    event.preventDefault();\n  });\n  const getInputContentFocusHandler = (0, _useEventCallback.default)(sectionIndex => () => {\n    setSelectedSections(sectionIndex);\n  });\n  const handleInputContentPaste = (0, _useEventCallback.default)(event => {\n    // prevent default to avoid the input `onInput` handler being called\n    event.preventDefault();\n    if (readOnly || disabled || typeof parsedSelectedSections !== 'number') {\n      return;\n    }\n    const activeSection = state.sections[parsedSelectedSections];\n    const pastedValue = event.clipboardData.getData('text');\n    const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);\n    const digitsOnly = /^[0-9]+$/.test(pastedValue);\n    const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);\n    const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly || activeSection.contentType === 'digit-with-letter' && digitsAndLetterOnly;\n    if (isValidPastedValue) {\n      resetCharacterQuery();\n      updateSectionValue({\n        activeSection,\n        newSectionValue: pastedValue,\n        shouldGoToNextSection: true\n      });\n    }\n    // If the pasted value corresponds to a single section, but not the expected type, we skip the modification\n    else if (!lettersOnly && !digitsOnly) {\n      resetCharacterQuery();\n      updateValueFromValueStr(pastedValue);\n    }\n  });\n  const handleInputContentDragOver = (0, _useEventCallback.default)(event => {\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'none';\n  });\n  const handleInputContentInput = (0, _useEventCallback.default)(event => {\n    if (!sectionListRef.current) {\n      return;\n    }\n    const target = event.target;\n    const keyPressed = target.textContent ?? '';\n    const sectionIndex = sectionListRef.current.getSectionIndexFromDOMElement(target);\n    const section = state.sections[sectionIndex];\n    if (readOnly || !sectionListRef.current) {\n      revertDOMSectionChange(sectionIndex);\n      return;\n    }\n    if (keyPressed.length === 0) {\n      if (section.value === '') {\n        revertDOMSectionChange(sectionIndex);\n        return;\n      }\n      const inputType = event.nativeEvent.inputType;\n      if (inputType === 'insertParagraph' || inputType === 'insertLineBreak') {\n        revertDOMSectionChange(sectionIndex);\n        return;\n      }\n      resetCharacterQuery();\n      clearActiveSection();\n      return;\n    }\n    applyCharacterEditing({\n      keyPressed,\n      sectionIndex\n    });\n\n    // The DOM value needs to remain the one React is expecting.\n    revertDOMSectionChange(sectionIndex);\n  });\n  (0, _useEnhancedEffect.default)(() => {\n    if (!focused || !sectionListRef.current) {\n      return;\n    }\n    if (parsedSelectedSections === 'all') {\n      sectionListRef.current.getRoot().focus();\n    } else if (typeof parsedSelectedSections === 'number') {\n      const domElement = sectionListRef.current.getSectionContent(parsedSelectedSections);\n      if (domElement) {\n        domElement.focus();\n      }\n    }\n  }, [parsedSelectedSections, focused]);\n  const sectionBoundaries = React.useMemo(() => {\n    return state.sections.reduce((acc, next) => {\n      acc[next.type] = sectionsValueBoundaries[next.type]({\n        currentDate: null,\n        contentType: next.contentType,\n        format: next.format\n      });\n      return acc;\n    }, {});\n  }, [sectionsValueBoundaries, state.sections]);\n  const isContainerEditable = parsedSelectedSections === 'all';\n  const elements = React.useMemo(() => {\n    return state.sections.map((section, index) => {\n      const isEditable = !isContainerEditable && !disabled && !readOnly;\n      return {\n        container: {\n          'data-sectionindex': index,\n          onClick: getInputContainerClickHandler(index)\n        },\n        content: {\n          tabIndex: isContainerEditable || index > 0 ? -1 : 0,\n          contentEditable: !isContainerEditable && !disabled && !readOnly,\n          role: 'spinbutton',\n          id: `${id}-${section.type}`,\n          'aria-labelledby': `${id}-${section.type}`,\n          'aria-readonly': readOnly,\n          'aria-valuenow': (0, _useField.getSectionValueNow)(section, utils),\n          'aria-valuemin': sectionBoundaries[section.type].minimum,\n          'aria-valuemax': sectionBoundaries[section.type].maximum,\n          'aria-valuetext': section.value ? (0, _useField.getSectionValueText)(section, utils) : translations.empty,\n          'aria-label': translations[section.type],\n          'aria-disabled': disabled,\n          spellCheck: isEditable ? false : undefined,\n          autoCapitalize: isEditable ? 'off' : undefined,\n          autoCorrect: isEditable ? 'off' : undefined,\n          [parseInt(React.version, 10) >= 17 ? 'enterKeyHint' : 'enterkeyhint']: isEditable ? 'next' : undefined,\n          children: section.value || section.placeholder,\n          onInput: handleInputContentInput,\n          onPaste: handleInputContentPaste,\n          onFocus: getInputContentFocusHandler(index),\n          onDragOver: handleInputContentDragOver,\n          onMouseUp: handleInputContentMouseUp,\n          inputMode: section.contentType === 'letter' ? 'text' : 'numeric'\n        },\n        before: {\n          children: section.startSeparator\n        },\n        after: {\n          children: section.endSeparator\n        }\n      };\n    });\n  }, [state.sections, getInputContentFocusHandler, handleInputContentPaste, handleInputContentDragOver, handleInputContentInput, getInputContainerClickHandler, handleInputContentMouseUp, disabled, readOnly, isContainerEditable, translations, utils, sectionBoundaries, id]);\n  const handleValueStrChange = (0, _useEventCallback.default)(event => {\n    updateValueFromValueStr(event.target.value);\n  });\n  const valueStr = React.useMemo(() => areAllSectionsEmpty ? '' : fieldValueManager.getV7HiddenInputValueFromSections(state.sections), [areAllSectionsEmpty, state.sections, fieldValueManager]);\n  React.useEffect(() => {\n    if (sectionListRef.current == null) {\n      throw new Error(['MUI X: The `sectionListRef` prop has not been initialized by `PickersSectionList`', 'You probably tried to pass a component to the `textField` slot that contains an `<input />` element instead of a `PickersSectionList`.', '', 'If you want to keep using an `<input />` HTML element for the editing, please remove the `enableAccessibleFieldDOMStructure` prop from your picker or field component:', '', '<DatePicker slots={{ textField: MyCustomTextField }} />', '', 'Learn more about the field accessible DOM structure on the MUI documentation: https://mui.com/x/react-date-pickers/fields/#fields-to-edit-a-single-element'].join('\\n'));\n    }\n    if (autoFocus && sectionListRef.current) {\n      sectionListRef.current.getSectionContent(sectionOrder.startIndex).focus();\n    }\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    interactions,\n    returnedValue: {\n      // Forwarded\n      autoFocus,\n      readOnly,\n      focused: focusedProp ?? focused,\n      sectionListRef: handleSectionListRef,\n      onBlur: handleContainerBlur,\n      onClick: handleContainerClick,\n      onFocus: handleContainerFocus,\n      onInput: handleContainerInput,\n      onPaste: handleContainerPaste,\n      // Additional\n      enableAccessibleFieldDOMStructure: true,\n      elements,\n      // TODO v7: Try to set to undefined when there is a section selected.\n      tabIndex: parsedSelectedSections === 0 ? -1 : 0,\n      contentEditable: isContainerEditable,\n      value: valueStr,\n      onChange: handleValueStrChange,\n      areAllSectionsEmpty\n    }\n  };\n};\nexports.useFieldV7TextField = useFieldV7TextField;","map":{"version":3,"names":["_interopRequireDefault","require","default","_interopRequireWildcard","Object","defineProperty","exports","value","useFieldV7TextField","React","_useForkRef","_useEventCallback","_useEnhancedEffect","_useId","_useField","_utils","_usePickersTranslations","_useUtils","params","internalProps","disabled","readOnly","forwardedProps","sectionListRef","inSectionListRef","onBlur","onClick","onFocus","onInput","onPaste","focused","focusedProp","autoFocus","fieldValueManager","applyCharacterEditing","resetCharacterQuery","setSelectedSections","parsedSelectedSections","state","clearActiveSection","clearValue","updateSectionValue","updateValueFromValueStr","sectionOrder","areAllSectionsEmpty","sectionsValueBoundaries","useRef","handleSectionListRef","translations","usePickersTranslations","utils","useUtils","id","setFocused","useState","interactions","useMemo","syncSelectionToDOM","current","selection","document","getSelection","rangeCount","getRoot","contains","getRangeAt","startContainer","removeAllRanges","blur","getActiveElement","range","window","Range","target","section","sections","type","getSectionContainer","getSectionContent","selectNodeContents","focus","addRange","getActiveSectionIndexFromDOM","activeElement","getSectionIndexFromDOMElement","focusField","newSelectedSections","newParsedSelectedSections","parseSelectedSections","newActiveSectionIndex","isFieldFocused","revertDOMSectionChange","sectionIndex","innerHTML","placeholder","handleContainerClick","event","args","isDefaultPrevented","setTimeout","cursorPosition","startOffset","startIndex","cursorOnStartOfSection","length","startSeparator","endSeparator","hasClickedOnASection","handleContainerInput","keyPressed","textContent","map","join","charCodeAt","handleContainerPaste","preventDefault","pastedValue","clipboardData","getData","handleContainerFocus","isFocusInsideASection","handleContainerBlur","shouldBlur","getInputContainerClickHandler","handleInputContentMouseUp","getInputContentFocusHandler","handleInputContentPaste","activeSection","lettersOnly","test","digitsOnly","digitsAndLetterOnly","isValidPastedValue","contentType","newSectionValue","shouldGoToNextSection","handleInputContentDragOver","dataTransfer","dropEffect","handleInputContentInput","inputType","nativeEvent","domElement","sectionBoundaries","reduce","acc","next","currentDate","format","isContainerEditable","elements","index","isEditable","container","content","tabIndex","contentEditable","role","getSectionValueNow","minimum","maximum","getSectionValueText","empty","spellCheck","undefined","autoCapitalize","autoCorrect","parseInt","version","children","onDragOver","onMouseUp","inputMode","before","after","handleValueStrChange","valueStr","getV7HiddenInputValueFromSections","useEffect","Error","returnedValue","enableAccessibleFieldDOMStructure","onChange"],"sources":["C:/Users/LENOVO/Desktop/spitalmanagement/node_modules/@mui/x-date-pickers/node/internals/hooks/useField/useFieldV7TextField.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useFieldV7TextField = void 0;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _useForkRef = _interopRequireDefault(require(\"@mui/utils/useForkRef\"));\nvar _useEventCallback = _interopRequireDefault(require(\"@mui/utils/useEventCallback\"));\nvar _useEnhancedEffect = _interopRequireDefault(require(\"@mui/utils/useEnhancedEffect\"));\nvar _useId = _interopRequireDefault(require(\"@mui/utils/useId\"));\nvar _useField = require(\"./useField.utils\");\nvar _utils = require(\"../../utils/utils\");\nvar _usePickersTranslations = require(\"../../../hooks/usePickersTranslations\");\nvar _useUtils = require(\"../useUtils\");\nconst useFieldV7TextField = params => {\n  const {\n    internalProps: {\n      disabled,\n      readOnly = false\n    },\n    forwardedProps: {\n      sectionListRef: inSectionListRef,\n      onBlur,\n      onClick,\n      onFocus,\n      onInput,\n      onPaste,\n      focused: focusedProp,\n      autoFocus = false\n    },\n    fieldValueManager,\n    applyCharacterEditing,\n    resetCharacterQuery,\n    setSelectedSections,\n    parsedSelectedSections,\n    state,\n    clearActiveSection,\n    clearValue,\n    updateSectionValue,\n    updateValueFromValueStr,\n    sectionOrder,\n    areAllSectionsEmpty,\n    sectionsValueBoundaries\n  } = params;\n  const sectionListRef = React.useRef(null);\n  const handleSectionListRef = (0, _useForkRef.default)(inSectionListRef, sectionListRef);\n  const translations = (0, _usePickersTranslations.usePickersTranslations)();\n  const utils = (0, _useUtils.useUtils)();\n  const id = (0, _useId.default)();\n  const [focused, setFocused] = React.useState(false);\n  const interactions = React.useMemo(() => ({\n    syncSelectionToDOM: () => {\n      if (!sectionListRef.current) {\n        return;\n      }\n      const selection = document.getSelection();\n      if (!selection) {\n        return;\n      }\n      if (parsedSelectedSections == null) {\n        // If the selection contains an element inside the field, we reset it.\n        if (selection.rangeCount > 0 && sectionListRef.current.getRoot().contains(selection.getRangeAt(0).startContainer)) {\n          selection.removeAllRanges();\n        }\n        if (focused) {\n          sectionListRef.current.getRoot().blur();\n        }\n        return;\n      }\n\n      // On multi input range pickers we want to update selection range only for the active input\n      if (!sectionListRef.current.getRoot().contains((0, _utils.getActiveElement)(document))) {\n        return;\n      }\n      const range = new window.Range();\n      let target;\n      if (parsedSelectedSections === 'all') {\n        target = sectionListRef.current.getRoot();\n      } else {\n        const section = state.sections[parsedSelectedSections];\n        if (section.type === 'empty') {\n          target = sectionListRef.current.getSectionContainer(parsedSelectedSections);\n        } else {\n          target = sectionListRef.current.getSectionContent(parsedSelectedSections);\n        }\n      }\n      range.selectNodeContents(target);\n      target.focus();\n      selection.removeAllRanges();\n      selection.addRange(range);\n    },\n    getActiveSectionIndexFromDOM: () => {\n      const activeElement = (0, _utils.getActiveElement)(document);\n      if (!activeElement || !sectionListRef.current || !sectionListRef.current.getRoot().contains(activeElement)) {\n        return null;\n      }\n      return sectionListRef.current.getSectionIndexFromDOMElement(activeElement);\n    },\n    focusField: (newSelectedSections = 0) => {\n      if (!sectionListRef.current ||\n      // if the field is already focused, we don't need to focus it again\n      interactions.getActiveSectionIndexFromDOM() != null) {\n        return;\n      }\n      const newParsedSelectedSections = (0, _useField.parseSelectedSections)(newSelectedSections, state.sections);\n      setFocused(true);\n      sectionListRef.current.getSectionContent(newParsedSelectedSections).focus();\n    },\n    setSelectedSections: newSelectedSections => {\n      if (!sectionListRef.current) {\n        return;\n      }\n      const newParsedSelectedSections = (0, _useField.parseSelectedSections)(newSelectedSections, state.sections);\n      const newActiveSectionIndex = newParsedSelectedSections === 'all' ? 0 : newParsedSelectedSections;\n      setFocused(newActiveSectionIndex !== null);\n      setSelectedSections(newSelectedSections);\n    },\n    isFieldFocused: () => {\n      const activeElement = (0, _utils.getActiveElement)(document);\n      return !!sectionListRef.current && sectionListRef.current.getRoot().contains(activeElement);\n    }\n  }), [parsedSelectedSections, setSelectedSections, state.sections, focused]);\n\n  /**\n   * If a section content has been updated with a value we don't want to keep,\n   * Then we need to imperatively revert it (we can't let React do it because the value did not change in his internal representation).\n   */\n  const revertDOMSectionChange = (0, _useEventCallback.default)(sectionIndex => {\n    if (!sectionListRef.current) {\n      return;\n    }\n    const section = state.sections[sectionIndex];\n    sectionListRef.current.getSectionContent(sectionIndex).innerHTML = section.value || section.placeholder;\n    interactions.syncSelectionToDOM();\n  });\n  const handleContainerClick = (0, _useEventCallback.default)((event, ...args) => {\n    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.\n    // We avoid this by checking if the call of `handleContainerClick` is actually intended, or a side effect.\n    if (event.isDefaultPrevented() || !sectionListRef.current) {\n      return;\n    }\n    setFocused(true);\n    onClick?.(event, ...args);\n    if (parsedSelectedSections === 'all') {\n      setTimeout(() => {\n        const cursorPosition = document.getSelection().getRangeAt(0).startOffset;\n        if (cursorPosition === 0) {\n          setSelectedSections(sectionOrder.startIndex);\n          return;\n        }\n        let sectionIndex = 0;\n        let cursorOnStartOfSection = 0;\n        while (cursorOnStartOfSection < cursorPosition && sectionIndex < state.sections.length) {\n          const section = state.sections[sectionIndex];\n          sectionIndex += 1;\n          cursorOnStartOfSection += `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`.length;\n        }\n        setSelectedSections(sectionIndex - 1);\n      });\n    } else if (!focused) {\n      setFocused(true);\n      setSelectedSections(sectionOrder.startIndex);\n    } else {\n      const hasClickedOnASection = sectionListRef.current.getRoot().contains(event.target);\n      if (!hasClickedOnASection) {\n        setSelectedSections(sectionOrder.startIndex);\n      }\n    }\n  });\n  const handleContainerInput = (0, _useEventCallback.default)(event => {\n    onInput?.(event);\n    if (!sectionListRef.current || parsedSelectedSections !== 'all') {\n      return;\n    }\n    const target = event.target;\n    const keyPressed = target.textContent ?? '';\n    sectionListRef.current.getRoot().innerHTML = state.sections.map(section => `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`).join('');\n    interactions.syncSelectionToDOM();\n    if (keyPressed.length === 0 || keyPressed.charCodeAt(0) === 10) {\n      resetCharacterQuery();\n      clearValue();\n      setSelectedSections('all');\n    } else if (keyPressed.length > 1) {\n      updateValueFromValueStr(keyPressed);\n    } else {\n      if (parsedSelectedSections === 'all') {\n        setSelectedSections(0);\n      }\n      applyCharacterEditing({\n        keyPressed,\n        sectionIndex: 0\n      });\n    }\n  });\n  const handleContainerPaste = (0, _useEventCallback.default)(event => {\n    onPaste?.(event);\n    if (readOnly || parsedSelectedSections !== 'all') {\n      event.preventDefault();\n      return;\n    }\n    const pastedValue = event.clipboardData.getData('text');\n    event.preventDefault();\n    resetCharacterQuery();\n    updateValueFromValueStr(pastedValue);\n  });\n  const handleContainerFocus = (0, _useEventCallback.default)((...args) => {\n    onFocus?.(...args);\n    if (focused || !sectionListRef.current) {\n      return;\n    }\n    setFocused(true);\n    const isFocusInsideASection = sectionListRef.current.getSectionIndexFromDOMElement((0, _utils.getActiveElement)(document)) != null;\n    if (!isFocusInsideASection) {\n      setSelectedSections(sectionOrder.startIndex);\n    }\n  });\n  const handleContainerBlur = (0, _useEventCallback.default)((...args) => {\n    onBlur?.(...args);\n    setTimeout(() => {\n      if (!sectionListRef.current) {\n        return;\n      }\n      const activeElement = (0, _utils.getActiveElement)(document);\n      const shouldBlur = !sectionListRef.current.getRoot().contains(activeElement);\n      if (shouldBlur) {\n        setFocused(false);\n        setSelectedSections(null);\n      }\n    });\n  });\n  const getInputContainerClickHandler = (0, _useEventCallback.default)(sectionIndex => event => {\n    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.\n    // We avoid this by checking if the call to this function is actually intended, or a side effect.\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n    setSelectedSections(sectionIndex);\n  });\n  const handleInputContentMouseUp = (0, _useEventCallback.default)(event => {\n    // Without this, the browser will remove the selected when clicking inside an already-selected section.\n    event.preventDefault();\n  });\n  const getInputContentFocusHandler = (0, _useEventCallback.default)(sectionIndex => () => {\n    setSelectedSections(sectionIndex);\n  });\n  const handleInputContentPaste = (0, _useEventCallback.default)(event => {\n    // prevent default to avoid the input `onInput` handler being called\n    event.preventDefault();\n    if (readOnly || disabled || typeof parsedSelectedSections !== 'number') {\n      return;\n    }\n    const activeSection = state.sections[parsedSelectedSections];\n    const pastedValue = event.clipboardData.getData('text');\n    const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);\n    const digitsOnly = /^[0-9]+$/.test(pastedValue);\n    const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);\n    const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly || activeSection.contentType === 'digit-with-letter' && digitsAndLetterOnly;\n    if (isValidPastedValue) {\n      resetCharacterQuery();\n      updateSectionValue({\n        activeSection,\n        newSectionValue: pastedValue,\n        shouldGoToNextSection: true\n      });\n    }\n    // If the pasted value corresponds to a single section, but not the expected type, we skip the modification\n    else if (!lettersOnly && !digitsOnly) {\n      resetCharacterQuery();\n      updateValueFromValueStr(pastedValue);\n    }\n  });\n  const handleInputContentDragOver = (0, _useEventCallback.default)(event => {\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'none';\n  });\n  const handleInputContentInput = (0, _useEventCallback.default)(event => {\n    if (!sectionListRef.current) {\n      return;\n    }\n    const target = event.target;\n    const keyPressed = target.textContent ?? '';\n    const sectionIndex = sectionListRef.current.getSectionIndexFromDOMElement(target);\n    const section = state.sections[sectionIndex];\n    if (readOnly || !sectionListRef.current) {\n      revertDOMSectionChange(sectionIndex);\n      return;\n    }\n    if (keyPressed.length === 0) {\n      if (section.value === '') {\n        revertDOMSectionChange(sectionIndex);\n        return;\n      }\n      const inputType = event.nativeEvent.inputType;\n      if (inputType === 'insertParagraph' || inputType === 'insertLineBreak') {\n        revertDOMSectionChange(sectionIndex);\n        return;\n      }\n      resetCharacterQuery();\n      clearActiveSection();\n      return;\n    }\n    applyCharacterEditing({\n      keyPressed,\n      sectionIndex\n    });\n\n    // The DOM value needs to remain the one React is expecting.\n    revertDOMSectionChange(sectionIndex);\n  });\n  (0, _useEnhancedEffect.default)(() => {\n    if (!focused || !sectionListRef.current) {\n      return;\n    }\n    if (parsedSelectedSections === 'all') {\n      sectionListRef.current.getRoot().focus();\n    } else if (typeof parsedSelectedSections === 'number') {\n      const domElement = sectionListRef.current.getSectionContent(parsedSelectedSections);\n      if (domElement) {\n        domElement.focus();\n      }\n    }\n  }, [parsedSelectedSections, focused]);\n  const sectionBoundaries = React.useMemo(() => {\n    return state.sections.reduce((acc, next) => {\n      acc[next.type] = sectionsValueBoundaries[next.type]({\n        currentDate: null,\n        contentType: next.contentType,\n        format: next.format\n      });\n      return acc;\n    }, {});\n  }, [sectionsValueBoundaries, state.sections]);\n  const isContainerEditable = parsedSelectedSections === 'all';\n  const elements = React.useMemo(() => {\n    return state.sections.map((section, index) => {\n      const isEditable = !isContainerEditable && !disabled && !readOnly;\n      return {\n        container: {\n          'data-sectionindex': index,\n          onClick: getInputContainerClickHandler(index)\n        },\n        content: {\n          tabIndex: isContainerEditable || index > 0 ? -1 : 0,\n          contentEditable: !isContainerEditable && !disabled && !readOnly,\n          role: 'spinbutton',\n          id: `${id}-${section.type}`,\n          'aria-labelledby': `${id}-${section.type}`,\n          'aria-readonly': readOnly,\n          'aria-valuenow': (0, _useField.getSectionValueNow)(section, utils),\n          'aria-valuemin': sectionBoundaries[section.type].minimum,\n          'aria-valuemax': sectionBoundaries[section.type].maximum,\n          'aria-valuetext': section.value ? (0, _useField.getSectionValueText)(section, utils) : translations.empty,\n          'aria-label': translations[section.type],\n          'aria-disabled': disabled,\n          spellCheck: isEditable ? false : undefined,\n          autoCapitalize: isEditable ? 'off' : undefined,\n          autoCorrect: isEditable ? 'off' : undefined,\n          [parseInt(React.version, 10) >= 17 ? 'enterKeyHint' : 'enterkeyhint']: isEditable ? 'next' : undefined,\n          children: section.value || section.placeholder,\n          onInput: handleInputContentInput,\n          onPaste: handleInputContentPaste,\n          onFocus: getInputContentFocusHandler(index),\n          onDragOver: handleInputContentDragOver,\n          onMouseUp: handleInputContentMouseUp,\n          inputMode: section.contentType === 'letter' ? 'text' : 'numeric'\n        },\n        before: {\n          children: section.startSeparator\n        },\n        after: {\n          children: section.endSeparator\n        }\n      };\n    });\n  }, [state.sections, getInputContentFocusHandler, handleInputContentPaste, handleInputContentDragOver, handleInputContentInput, getInputContainerClickHandler, handleInputContentMouseUp, disabled, readOnly, isContainerEditable, translations, utils, sectionBoundaries, id]);\n  const handleValueStrChange = (0, _useEventCallback.default)(event => {\n    updateValueFromValueStr(event.target.value);\n  });\n  const valueStr = React.useMemo(() => areAllSectionsEmpty ? '' : fieldValueManager.getV7HiddenInputValueFromSections(state.sections), [areAllSectionsEmpty, state.sections, fieldValueManager]);\n  React.useEffect(() => {\n    if (sectionListRef.current == null) {\n      throw new Error(['MUI X: The `sectionListRef` prop has not been initialized by `PickersSectionList`', 'You probably tried to pass a component to the `textField` slot that contains an `<input />` element instead of a `PickersSectionList`.', '', 'If you want to keep using an `<input />` HTML element for the editing, please remove the `enableAccessibleFieldDOMStructure` prop from your picker or field component:', '', '<DatePicker slots={{ textField: MyCustomTextField }} />', '', 'Learn more about the field accessible DOM structure on the MUI documentation: https://mui.com/x/react-date-pickers/fields/#fields-to-edit-a-single-element'].join('\\n'));\n    }\n    if (autoFocus && sectionListRef.current) {\n      sectionListRef.current.getSectionContent(sectionOrder.startIndex).focus();\n    }\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    interactions,\n    returnedValue: {\n      // Forwarded\n      autoFocus,\n      readOnly,\n      focused: focusedProp ?? focused,\n      sectionListRef: handleSectionListRef,\n      onBlur: handleContainerBlur,\n      onClick: handleContainerClick,\n      onFocus: handleContainerFocus,\n      onInput: handleContainerInput,\n      onPaste: handleContainerPaste,\n      // Additional\n      enableAccessibleFieldDOMStructure: true,\n      elements,\n      // TODO v7: Try to set to undefined when there is a section selected.\n      tabIndex: parsedSelectedSections === 0 ? -1 : 0,\n      contentEditable: isContainerEditable,\n      value: valueStr,\n      onChange: handleValueStrChange,\n      areAllSectionsEmpty\n    }\n  };\n};\nexports.useFieldV7TextField = useFieldV7TextField;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}